## 3.1 리액트의 모든 훅 파헤치기

훅은 클래스형 컴포넌트에서만 가능했던 state, ref 등 리액트의 핵심적인 기능을 함수에서도 가능하게 만듦
또한, 클래스형 컴포넌트보다 간결하게 작성할 수 있음

### 3.1.1 useState

useState는 함수형 컴포넌트 내부에서 상태를 정의하고, 이 상태를 관리할 수 있게 해주는 훅임
useState의 내부 구현을 예상해보면 아래와 같음

```javascript
function useState(initialValue) {
  let internalState = initialValue;

  function setState(newValue) {
    internalState = newValue;
  }

  return [internalState, setState];
}
```

하지만 우리가 원하는대로 작동하지 않는데, 이는 setValue로 값을 변경했음에도 이미 구조 분해 할당으로 state 값을 할당해 놓았기 떄문에 훅 내부의 setState를 호출해도 변경된 새로운 값을 반환하지 못함
이를 해결하기 위해서는 먼저 state를 함수로 바꿔 state의 값을 호출할 때마다 현재 state를 반환하게 하면 됨

```javascript
function useState(initialValue) {
  let internalState = initialValue;

  function state() {
    return internalState;
  }

  function setState(newValue) {
    internalState = newValue;
  }

  return [state, setState];
}

const [value, setValue] = useState(0);
setValue(1);
console.log(value()); // 1
```

하지만 우리는 state를 함수가 아닌 상수로 사용함
이를 위해서 리액트는 클로저를 이용함
클로저는 함수 내부에 선언된 함수가 함수의 실행이 종료된 이후에도 지역 변수를 계속 참조할 수 있는 것을 의미함

아래 코드는 useState 작동 방식을 흉내 낸 코드임

```javascript
const MyReact = function () {
  const global = {};
  let index = 0;

  function useState(initialState) {
    if (!global.states) {
      global.states = [];
    }

    const currentState = global.states[index] || initialState;
    global.states[index] = currentState;

    const setState = (function () {
      let currentIndex = index;
      return function (value) {
        global.states[currentIndex] = value;
      };
    })();

    index = index + 1;

    return [currentState, setState];
  }
};
```

실제 리액트 코드에서는 useState가 useReducer를 이용해 구현돼 있음
여기서 함수의 실행이 끝났음에도 함수가 선언된 환경을 기억할 수 있는 방법은 클로저임
클로저를 사용해 외부에 해당 값을 노출시키지 않고 오직 리액트에서만 쓸 수 있었고, 함수형 컴포넌트가 매번 실행돼도 useState에 이전 값을 정확하게 꺼내 쓸 수 있게 됨

useState의 인수로 특정한 값을 넘기는 함수를 인수로 넣어줄 수도 있는데, 변수 대신 함수를 넘기는 것을 게으른 초기화라고 함
게으른 초기화는 useState의 초기값이 복잡하거나 무거운 연산을 포함하고 있는 경우 사용함
이후 리렌더링이 발생하면 이 함수의 실행은 무시됨

```javascript
const [count, setCount] = useState(() =>
  Number.parseInt(window.localStorage.getItem(cacheKey))
);
```

리액트에서는 렌더링이 실행될 때마다 함수형 컴포넌트의 함수가 다시 실행됨
함수형 컴포넌트의 useState 값도 재실행됨
useState의 인수로 많은 비용을 요구하는 작업이 들어가 있다면 계속해서 실행될 수도 있음
하지만 useState 내부에 함수를 넣으면 이는 최초 렌더링 이후 실행되지 않음
Number.parseInt(window.localStorage.getItem(cacheKey)) 이 값 자체를 인수로 사용하면 초기값이 필요한 최초 렌더링과 이후 리렌더링 시에도 동일하게 해당 값에 접근할 것임
하지만, 함수 형태로 인수로 넘겨주면 초기값이 없을 때만 함수를 실행하고 이후에는 함수를 실행하지 않을 것임
이런 게으른 초기화는 localStorage나 sessionStorage에 대한 접근, map, filter, find 같은 배열에 대한 접근, 그리고 무거운 연산을 포함해 실행 비용이 많이 드는 경우 사용하는 것이 좋음
