# 2.4 렌더링은 어떻게 일어나는가?

## 리액트의 렌더링이란?

**리액트의 렌더링**이란 리액트 어플리케이션 트리 안에 있는 모든 컴포넌트들이 **props와 state의 값**을 기반으로 **어떻게 UI를 구성**하고 **어떤 DOM 결과를 제공**할 것인지 계산하는 **일련의 과정**을 말한다.

## 리액트의 렌더링이 일어나는 이유

1. 최초 렌더링: 사용자가 어플리케이션에 최초 진입했을 때 수행하는 작업이다.
2. 리렌더링: 최초렌더링 이후로 발생하는 모든 렌더링이다. 리렌더링이 발생하는 경우는 아래와 같다.
   - 클래스 컴포넌트의 **setState가 실행**되는 경우
   - 클래스 컴포넌트의 **forceUpdate가 실행**되는 경우
   - 함수 컴포넌트의 <b>useState()</b>의 두 번째 배열 요소인 **setter가 실행**되는 경우
   - 함수 컴포넌트의 <b>useReducer()</b>의 두 번째 배열 요소인 **dispatch가 실행**되는 경우
   - 컴포넌트의 **key props가 변경**되는 경우
   - **props가 변경**되는 경우
   - **부모 컴포넌트가 렌더링**될 경우

## 리액트의 렌더링 프로세스

렌더링 프로세스가 시작되면 **컴포넌트의 루트에서부터 아래쪽**으로 내려가면서 **업데이트가 필요한 컴포넌트를 찾는다.** 업데이트가 필요한 컴포넌트에 대해서 **클래스 컴포넌트**는 <b>render()</b>를, **함수 컴포넌트**의 경우 **함수 자체를 호출**한 뒤에, 그 결과물을 저장한다.

JSX로 작성된 코드를 컴파일하여 React.createElement()를 호출하는 구문으로 바뀌고, createElement는 일반적인 자바스크립트 객체를 반환한다.

```jsx
// 컴파일 전
function Hello() {
  return (
    <TestComponent a={35} b="yceffort">
      안녕하세요
    </TestComponent>
  );
}

// 컴파일 후
function Hello() {
  return React.createElement(TestComponent, { a: 35, b: "yceffort" }, "안녕하세요");
}
```

```JSON
// createElement 결과물
{
  "type": TestComponent,
  "props": {
    "a": 35,
    "b": "yceffort",
    "children":"안녕하세요"
  }
}
```

렌더링 프로세스가 실행되면 **새로운 트리인 가상 DOM과 비교해 실제 DOM에 반영하기 위한 변경 사항을 차례차례 수집**한다.

이러한 과정을 <b>재조정(Reconciliation)</b>이라고 한다. 재조정이 끝나면 **모든 변경 사항**을 하나의 **동기 시퀀스로 DOM에 적용**해 변경된 결과물이 보이게 된다.

## 렌더와 커밋

> 렌더 단계

컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업을 말한다. 즉, 렌더링 프로세스에서 컴포넌트를 실행한 결과와 이전 가상 DOM을 비교해 **변경이 필요한 컴포넌트를 체크하는 단계**이다.

> 커밋 단계

렌더 단계의 **변경 사항을 실제 DOM에 적용**하여 사용자에게 보여주는 과정으로, 이 과정이 끝나야 **브라우저의 렌더링**이 일어난다. **렌더 단계**에서 **변경 사항이 감지되지 않는다**면 **커밋 단계**는 **생략**될 수 있다. 즉, **브라우저의 DOM 업데이트가 일어나지 않을 수 있다.**

렌더링 프로세스의 특성상 **동기적으로 렌더링**해야하지만 특정 상황의 경우 **비동기적으로 렌더링**하는 것이 유효할 수 있다. 비동기적 렌더링, 즉 **동시성 렌더링**이 리액트 18에 도입됐다. 이 동시성 렌더링을 통해 **특정 렌더링의 우선순위를 낮추**거나, 필요하다면 **중단하거나 재시작**하거나, **경우에 따라서는 포기**할 수 있다.

이를 통해 브라우저의 동기 작업을 차단하지 않고 **백그라운드에서 새로운 리액트 트리를 준비**할 수 있으므로 사용자는 **더욱 매끄러운 사용자 경험**을 누릴 수 있다.
