# 1.5 이벤트 루프와 비동기 통신의 이해

## 싱글 스레드 자바스크립트

자바스크립트가 싱글 스레드인 이유는 만들어졌을 당시 멀티 스레드에 대한 개념이 대중적인 시기가 아니었기 때문이다.

### 싱글 스레드 vs 멀티 스레드

**싱글 스레드**는 하나의 프로세스에 **스레드가 1개**만 있는 것으로 **한 번에 하나의 작업**만 처리할 수 있다.(직렬, 동기적)
</br>
**멀티 스레드**는 하나의 프로세스에 **여러 개의 스레드**가 있어 **한 번에 다수의 작업**을 처리할 수 있다.(병렬, 비동기적)

위 비교를 보면 멀티 스레드가 싱글 스레드보다 좋지만 멀티 스레드에도 단점이 있다.

- 공유 자원에 대해 동시 접근하는 문제가 발생할 수 있음
- 하나의 스레드에서 문제가 생기면 자원을 공유하는 다른 스레드에도 문제가 발생할 수 있음

### Run-to-completion

**Run-to-completion**이란 하나의 코드가 실행하는데 오래 걸리면 뒤이은 코드가 실행되지 않는다는 개념이다.
</br>
즉, 자바스크립트의 모든 코드는 동기식으로 **한 번에 하나씩 순차적으로 처리**된다.

## 이벤트 루프란?

**이벤트 루프**란 자바스크립트 런타임 외부에서 **자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치**이다.

### 호출 스택과 이벤트 루프

**호출 스택(call stack)**이란 자바스크립트에서 수행해야 할 **코드나 함수를 순차적으로 담아두는 스택**이다.

```typescript
// 동기적 실행
function bar() {
  console.log("bar");
}

function baz() {
  console.log("baz");
}

function foo() {
  console.log("foo");
  bar();
  baz();
}

foo(); // foo bar baz
```

위 코드들은 다음과 같은 순서로 호출 스택에 쌓이고 지워진다.

1. `foo()`가 호출 스택에 들어간다.
2. `foo()`의 `console.log`가 호출 스택에 들어가고 실행된다.
3. `bar()`가 호출 스택에 들어간다.
4. `bar()`의 `console.log`가 호출 스택에 들어가고 실행된다.
5. `bar()`는 더이상 실행할 코드가 없으므로 호출 스택에서 지워진다.
6. `baz()`가 호출 스택에 들어간다.
7. `baz()`의 `console.log`가 호출 스택에 들어가고 실행된다.
8. `baz()`는 더이상 실행할 코드가 없으므로 호출 스택에서 지워진다.
9. `foo()`는 더이상 실행할 코드가 없으므로 호출 스택에서 지워진다.
10. 호출 스택이 모두 비워졌다.

이 **호출 스택이 비어 있는지 여부**를 확인하는 것이 바로 **이벤트 루프**이다.
</br>
호출 스택의 공백 여부 확인과 코드 실행은 싱글 스레드에서 일어난다. 따라서 두 작업은 순차적으로 발생한다.

```typescript
// 비동기적 실행
function bar() {
  console.log("bar");
}

function baz() {
  console.log("baz");
}

function foo() {
  console.log("foo");
  setTimeout(bar, 0);
  baz();
}

foo(); // foo baz bar
```

1. `foo()`가 호출 스택에 들어간다.
2. `foo()`의 `console.log`가 호출 스택에 들어가고 실행된다.
3. `bar()`가 태스크 큐로 들어가고 호출 스택에서 지워진다.
4. `baz()`가 호출 스택에 들어간다.
5. `baz()`의 `console.log`가 호출 스택에 들어가고 실행된다.
6. `baz()`는 더이상 실행할 코드가 없으므로 호출 스택에서 지워진다.
7. `foo()`는 더이상 실행할 코드가 없으므로 호출 스택에서 지워진다.
8. 호출 스택이 비어있는 것을 확인 후 태스크 큐에 있던 `bar()`를 호출 스택에 넣는다.
9. `bar()`의 `console.log`가 호출 스택에 들어가고 실행된다.
10. `bar()`는 더이상 실행할 코드가 없으므로 호출 스택에서 지워진다.
11. 호출 스택이 모두 비워졌다.

n초 뒤에 실행할 **setTimeout 작업** 혹은 **fetch**를 이용한 네트워크 통신 작업은 어떻게 처리할까?
</br>
이러한 작업들은 **외부 Web API**의 도움을 받아 처리하고 **콜백이 태스크 큐로 들어간다.**

## 태스크 큐와 마이크로 태스크 큐

**이벤트 루프에서 태스크 큐**는 FIFO(First In First Out)의 큐가 아니라 **set의 형태**를 띠고 있다.
</br>
이는 실행 가능한 태스크 큐부터 꺼내기 때문이다.

**마이크로 태스크 큐**에는 대표적으로 **Promise**가 있다. 마이크로 태스크 큐는 **태스크 큐보다 우선순위**를 가지게 된다. 즉, 마이크로 태스크 큐가 빌 때까지는 기존 태스크 큐의 실행은 뒤로 미루어진다.

```typescript
function foo() {
  console.log("foo");
}

function bar() {
  console.log("bar");
}

function baz() {
  console.log("baz");
}

setTimeout(foo, 0);

Promise.resolve().then(bar).then(baz); // bar baz foo
```

태스크 큐와 마이크로 태스크 큐에 들어가는 대표적인 작업들은 다음과 같다.

- 태스크 큐: setTimeout, setInterval, setImmediate
- 마이크로 태스크 큐: process.nextTick, Promises, queueMicroTask, MutationObserver
