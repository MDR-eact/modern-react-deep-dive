# 🌟 2.3 클래스 컴포넌트와 함수 컴포넌트
## 📌 2.3.1 클래스 컴포넌트
- constructor()
  - 컴포넌트 초기화되는 시점에 호출
  - state 초기화
  - super()는 컴포넌트를 만들면서 상속받은 상위 컴포넌트, 즉 React.Component의 생성자 함수를 먼저 호출해 상위 컴포넌트 접근 가능

- props
  - 컴포넌트에 특정 속성 전달

- state
  - 클래스 컴포넌트 내부에서 관리하는 값
  - 항상 객체
  - 변화가 있을 때마다 리렌더링 발생

- 메서드
  - 렌더링 함수 내부에서 사용되는 함수
  - DOM에서 발생하는 이벤트와 함께 사용

### 클래스 컴포넌트의 생명주기 메서드
마욷트: 컴포넌트가 마운팅(생성)되는 시점
업데이트: 이미 생성된 컴포넌트의 내용이 변경되는 시점
언마운트: 컴포넌트가 더이상 존재하지 않는 시점
- render()
  - UI 렌더링
  - 마운트와 업데이트 과정
- coponentDidMount()
  - 마운트되고 준비되는 즉시 실행
- componetDidUpdate()
  - 컴포넌트 업데이트가 일어난 이후 바로 실행
- componentWillUnmount()
  - 언마운트되거나 더 이상 사용되지 않기 직전에 호출
- shouldComponentUpdate()
  - 컴포넌트에 영향을 받지 않는 변화에 대해 정의
  - state나 props의 변경으로 리액트 컴포넌트가 다시 리렌더링되는 것을 막고 싶을 때 사용
- getDerivedStateFromProps()
  - render() 호출하기 직전에 호출
- getSnapShotBeforeUpdate()
  - DOM이 업데이트되기 직전에 호출
  - 윈도우 크기 조절, 스크롤 위치 조정등의 작업 처리에 유용
- getDerivedStateFromError()
  - 자식 컴포넌트에서 에러가 발생했을 때 호출되는 에러 메서드
- componentDidCatch()
  - 자식 컴포넌트에서 에러가 발생했을 때 실행됨
  - getDerivedStateFromError에서 에러를 잡고 state를 결정한 이후에 실행

### 클래스 컴포넌트의 한계
- 데이터의 흐름을 추적하기 어렵다
- 애플리케이션 내부 로직의 재사용이 어렵다
- 기능이 많아질수록 컴포넌트의 크기가 커진다
- 클래스는 함수에 비해 상대적으로 어렵다
- 핫 리로딩을 하는데 상대적으로 불리하다
  - 핫 리로딩: 코드에 변경 사항이 발생했을 때 앱을 다시 시작하지 않고서도 해당 변경된 코드만 업데이트해 변경 사항을 빠르게 적용하는 기법, 개발 단계에서 많이 사용 (애플리케이션을 실행한 채로 코드의 수정 내용이 바로 반영되는 것)

## 📌 2.3.2 함수 컴포넌트
간결해짐

## 📌 2.3.3 함수 컴포넌트 vs 클래스 컴포넌트
- 생명주기 메서드의 부재
- 함수 컴포넌트와 렌더링된 값
