# 🌟 2.2 가상 DOM과 리액트 파이버

## 📌 2.2.1 DOM과 브라우저 렌더링 과정

### 렌더링 과정

1. 요청한 주소를 방문해 HTML 파일 다운로드
2. 브라우저의 렌더링 엔진은 HTML을 파싱해 DOM 트리 생성
3. 2번 과정에서 CSS 파일을 만나면 CSS 파일 다운로드
4. CSSOM 트리 생성
5. 2번에서 만든 DOM 노드 순회. 이때 사용자의 눈에 보이는 노드만 방문
6. 5번에서 순회한 노드에 대한 CSSOM 정보를 찾고, 여기서 발견한 CSS 스타일 정보를 노트에 적용

- 레이아웃: 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정
- 페인팅: 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정

## 📌 2.2.2 가상 DOM의 탄생 배경

- 사용자의 인터랙션에 따라 DOM의 모든 변경 사항을 추적하는 것은 수고로움
- 가상 DOM은 웹페이지가 표시해야 할 DOM이 아닌 리액트가 관리하는 가상의 DOM
- 브라우저가 아닌 메모리에서 계산하는 과정을 한번 거치게 된다면 실제로는 여러 번 발생했을 렌더링 과정을 최소화

## 📌 2.2.3 가상 DOM을 위한 아키텍처, 리액트 파이버

- 가상 DOM과 렌더링 과정 최적화를 가능하게 해주는 것

### 리액트 파이버란?

- 리액트에서 관리하는 평범한 자바스크립트 객체
- 파이버는 파이버 재조정자가 관리하는데, 이는 앞서 이야기한 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하며, 만약 이 둘 사이에 차이가 있으면 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청하는 역할

파이버가 하는 일

- 작업을 작은 단위로 분할하고 쪼갠다음, 우선순위를 매긴다
- 이러한 작업을 일시 중지하고 나중에 다시 시작할 수 있다.
- 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우에는 폐기할 수 있다.

파이버를 도입하기 전과의 차이점

- 이전에는 조정 알고리즘이 스택 알고리즘으로 이뤄져 있었다. 하나의 스택에 렌더링에 필요한 작업들이 쌓이면 이 스택이 빌 때까지 동기적으로 작업이 이루어져 비효율적이었다. 하지만 파이버는 비동기로 일을 수행한다.

### 리액트 파이버 트리

- 파이버 트리는 리액트 내부에 두개 존재
  - 현재 모습을 담은 파이버 트리
  - 작업 중인 상태를 나타내는 workInProgress 트리
- 리액트 파이버의 작업이 끝나면 리액트는 단순히 포인터만 변경해 workInProgress 트리를 현재 트리로 바꿔버림 => 더블 버퍼링

### 파이버의 작업 순서

1. 리액트는 beginWork() 함수를 실행해 파이버 작업을 수행하는데, 더 이상 작업이 없는 파이버를 만날 때까지 트리 형식으로 시작된다
2. 1번에서 작업이 끝난다면 그다음 completeWork() 함수를 실행해 파이버 작업을 완료한다
3. 형제가 있다면 형제로 넘어간다
4. 2번, 3번이 모두 끝났다면 return으로 돌아가 자신의 작업이 완료되었음을 알린다
5. 루트 노드가 완성되는 순간, 최종적으로 commitWork()가 수행되고 이 중에 변경 사항을 비교해 업데이트가 필요한 변경 사항이 DOM에 반영된다

## 📌 2.2.4. 파이버와 가상 DOM

- 파이버: 리액트 컴포넌트에 대한 정보를 1:1로 가지고 있는 것, 리액트 아키텍처 내부에서 비동기로 이뤄짐
- 실제 브라우저 구조인 DOM에 반영하는 것은 동기적으로 일어나야 함, 따라서 메모리 상에서 먼저 수행해서 최종적인 결과물만 DOM에 적용

#### +) 그러면 파이버를 바탕으로 가상 DOM을 만드는 것인가?
https://velog.io/@yesbb/virtual-dom%EC%9D%98-%EC%84%B1%EB%8A%A5%EC%9D%B4-%EB%8D%94-%EC%A2%8B%EC%9D%80%EC%9D%B4%EC%9C%A0#43-fiber%EC%9D%98-2%EA%B0%80%EC%A7%80-%EB%8B%A8%EA%B3%84--render--commit

#### +) 가상돔이 더 효율적인 이유
변경 사항을 모았다가 한꺼번에 실제 돔에 반영하기 때문<br/>
React는 state 업데이트를 하기 전에 이벤트 핸들러의 모든 코드가 실행될 때까지 기다린후 배칭(일괄처리)한다 <br/>

```js
<button onClick={() => {
  setNumber(n => n + 1);
  setNumber(n => n + 1);
  setNumber(n => n + 1);
}}>+3</button>
```

1. React는 이벤트 핸들러의 다른 코드가 모두 실행된 후에 이 함수가 처리되도록 큐에 넣는다.
2. 다음 렌더링 중에 React는 큐를 순회하여 최종 업데이트된 state를 제공한다.

https://react-ko.dev/learn/queueing-a-series-of-state-updates
